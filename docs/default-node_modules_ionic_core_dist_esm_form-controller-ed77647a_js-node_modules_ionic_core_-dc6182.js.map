{"version":3,"file":"default-node_modules_ionic_core_dist_esm_form-controller-ed77647a_js-node_modules_ionic_core_-dc6182.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AAC2D;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,0BAA0B,GAAIC,EAAE,IAAK;EACzC,MAAMC,SAAS,GAAGD,EAAE;EACpB,IAAIE,aAAa;EACjB,MAAMC,gBAAgB,GAAG,MAAM;IAC7B,IAAID,aAAa,KAAKE,SAAS,EAAE;MAC/B;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACM,MAAMC,YAAY,GAAGJ,SAAS,CAACK,KAAK,KAAKF,SAAS,IAAIG,YAAY,CAACN,SAAS,CAAC;MAC7E,MAAMO,qBAAqB,GAAGP,SAAS,CAACQ,YAAY,CAAC,YAAY,CAAC;MAChE;MACCR,SAAS,CAACQ,YAAY,CAAC,iBAAiB,CAAC,IAAIR,SAAS,CAACS,UAAU,KAAK,IAAK;MAC9E,MAAMC,eAAe,GAAGb,uDAAa,CAACG,SAAS,CAAC;MAChD;AACN;AACA;AACA;MACMC,aAAa,GACXD,SAAS,CAACW,MAAM,KAAK,IAAI,IAAK,CAACP,YAAY,IAAI,CAACG,qBAAqB,IAAIG,eAAe,KAAK,IAAK;IACtG;IACA,OAAOT,aAAa;EACtB,CAAC;EACD,OAAO;IAAEC;EAAiB,CAAC;AAC7B,CAAC;AACD,MAAMI,YAAY,GAAIN,SAAS,IAAK;EAClC,MAAMY,IAAI,GAAGZ,SAAS,CAACS,UAAU;EACjC,IAAIG,IAAI,KAAK,IAAI,EAAE;IACjB,OAAO,KAAK;EACd;EACA;AACF;AACA;AACA;AACA;EACE,IAAIC,2BAA2B,CAACC,QAAQ,CAACd,SAAS,CAACe,OAAO,CAAC,IAAIf,SAAS,CAACgB,aAAa,CAAC,gBAAgB,CAAC,KAAK,IAAI,EAAE;IACjH,OAAO,IAAI;EACb;EACA;AACF;AACA;AACA;AACA;EACE,IAAIC,6BAA6B,CAACH,QAAQ,CAACd,SAAS,CAACe,OAAO,CAAC,IAAIf,SAAS,CAACkB,WAAW,KAAK,EAAE,EAAE;IAC7F,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd,CAAC;AACD,MAAML,2BAA2B,GAAG,CAAC,WAAW,CAAC;AACjD,MAAMI,6BAA6B,GAAG,CAAC,YAAY,EAAE,cAAc,EAAE,WAAW,CAAC;;;;;;;;;;;;;;;;;;;ACjEjF;AACA;AACA;AAC+C;AACE;AACQ;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMS,4BAA4B,GAAG,CAAC3B,EAAE,EAAE4B,QAAQ,EAAEC,gBAAgB,KAAK;EACvE,IAAIC,oBAAoB;EACxB,IAAIC,8BAA8B;EAClC,IAAIT,iDAAG,KAAKlB,SAAS,IAAI,uEAAyB,EAAE;IAClD0B,oBAAoB,GAAG,IAAIE,gBAAgB,CAAEC,OAAO,IAAK;MACvD,KAAK,MAAMC,KAAK,IAAID,OAAO,EAAE;QAC3B,KAAK,MAAME,IAAI,IAAID,KAAK,CAACE,UAAU,EAAE;UACnC;AACV;AACA;AACA;UACU,IAAID,IAAI,CAACE,QAAQ,KAAKC,IAAI,CAACC,YAAY,IAAIJ,IAAI,CAACK,IAAI,KAAKZ,QAAQ,EAAE;YACjE;AACZ;AACA;AACA;AACA;YACYC,gBAAgB,EAAE;YAClB;AACZ;AACA;AACA;AACA;AACA;YACYL,uDAAG,CAAC,MAAMiB,kBAAkB,CAACN,IAAI,CAAC,CAAC;YACnC;UACF;QACF;MACF;IACF,CAAC,CAAC;IACFL,oBAAoB,CAACY,OAAO,CAAC1C,EAAE,EAAE;MAC/B2C,SAAS,EAAE;IACb,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMF,kBAAkB,GAAIG,SAAS,IAAK;IACxC,IAAIC,EAAE;IACN,IAAId,8BAA8B,EAAE;MAClCA,8BAA8B,CAACe,UAAU,EAAE;MAC3Cf,8BAA8B,GAAG3B,SAAS;IAC5C;IACA2B,8BAA8B,GAAG,IAAIC,gBAAgB,CAAEC,OAAO,IAAK;MACjEJ,gBAAgB,EAAE;MAClB,KAAK,MAAMK,KAAK,IAAID,OAAO,EAAE;QAC3B,KAAK,MAAME,IAAI,IAAID,KAAK,CAACa,YAAY,EAAE;UACrC;AACV;AACA;AACA;AACA;UACU,IAAIZ,IAAI,CAACE,QAAQ,KAAKC,IAAI,CAACC,YAAY,IAAIJ,IAAI,CAACK,IAAI,KAAKZ,QAAQ,EAAE;YACjEoB,6BAA6B,EAAE;UACjC;QACF;MACF;IACF,CAAC,CAAC;IACF;AACJ;AACA;AACA;AACA;AACA;IACIjB,8BAA8B,CAACW,OAAO,CAAC,CAACG,EAAE,GAAGD,SAAS,CAACK,aAAa,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGD,SAAS,EAAE;MAAEM,OAAO,EAAE,IAAI;MAAEP,SAAS,EAAE;IAAK,CAAC,CAAC;EACvJ,CAAC;EACD,MAAMQ,OAAO,GAAG,MAAM;IACpB,IAAIrB,oBAAoB,EAAE;MACxBA,oBAAoB,CAACgB,UAAU,EAAE;MACjChB,oBAAoB,GAAG1B,SAAS;IAClC;IACA4C,6BAA6B,EAAE;EACjC,CAAC;EACD,MAAMA,6BAA6B,GAAG,MAAM;IAC1C,IAAIjB,8BAA8B,EAAE;MAClCA,8BAA8B,CAACe,UAAU,EAAE;MAC3Cf,8BAA8B,GAAG3B,SAAS;IAC5C;EACF,CAAC;EACD,OAAO;IACL+C;EACF,CAAC;AACH,CAAC;AAED,MAAMC,cAAc,GAAG,CAACC,KAAK,EAAEC,SAAS,EAAEC,gBAAgB,KAAK;EAC7D,MAAMC,WAAW,GAAGH,KAAK,IAAI,IAAI,GAAG,CAAC,GAAGA,KAAK,CAACI,QAAQ,EAAE,CAACC,MAAM;EAC/D,MAAMC,kBAAkB,GAAGC,uBAAuB,CAACJ,WAAW,EAAEF,SAAS,CAAC;EAC1E;AACF;AACA;AACA;EACE,IAAIC,gBAAgB,KAAKnD,SAAS,EAAE;IAClC,OAAOuD,kBAAkB;EAC3B;EACA;AACF;AACA;AACA;AACA;EACE,IAAI;IACF,OAAOJ,gBAAgB,CAACC,WAAW,EAAEF,SAAS,CAAC;EACjD,CAAC,CACD,OAAOO,CAAC,EAAE;IACRnC,qDAAa,CAAC,2CAA2C,EAAEmC,CAAC,CAAC;IAC7D,OAAOF,kBAAkB;EAC3B;AACF,CAAC;AACD,MAAMC,uBAAuB,GAAG,CAACF,MAAM,EAAEI,SAAS,KAAK;EACrD,OAAQ,GAAEJ,MAAO,MAAKI,SAAU,EAAC;AACnC,CAAC;;;;;;;;;;;;;;;;;ACnID;AACA;AACA;AAC+C;AACE;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,qBAAqB,GAAG,CAAChE,EAAE,EAAEiE,gBAAgB,EAAEC,YAAY,KAAK;EACpE,IAAIC,iBAAiB;EACrB,MAAMC,uBAAuB,GAAG,MAAM;IACpC,MAAMC,aAAa,GAAGJ,gBAAgB,EAAE;IACxC;IACA;AACJ;AACA;AACA;IACII,aAAa,KAAKjE,SAAS;IACzB;AACN;AACA;AACA;AACA;IACMJ,EAAE,CAACM,KAAK,KAAKF,SAAS,IACtB8D,YAAY,EAAE,KAAK,IAAI,EAAE;MACzB,OAAO,KAAK;IACd;IACA,OAAO,IAAI;EACb,CAAC;EACD,MAAMI,mBAAmB,GAAG,MAAM;IAChC,IAAIF,uBAAuB,EAAE,EAAE;MAC7B;AACN;AACA;AACA;AACA;AACA;MACM5C,uDAAG,CAAC,MAAM;QACR+C,aAAa,EAAE;MACjB,CAAC,CAAC;IACJ;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMA,aAAa,GAAG,MAAM;IAC1B,MAAMF,aAAa,GAAGJ,gBAAgB,EAAE;IACxC,IAAII,aAAa,KAAKjE,SAAS,EAAE;MAC/B;IACF;IACA,IAAI,CAACgE,uBAAuB,EAAE,EAAE;MAC9BC,aAAa,CAACG,KAAK,CAACC,cAAc,CAAC,OAAO,CAAC;MAC3C;IACF;IACA,MAAMC,KAAK,GAAGR,YAAY,EAAE,CAACS,WAAW;IACxC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACID,KAAK,KAAK,CAAC,IACTL,aAAa,CAACO,YAAY,KAAK,IAAI,IACnCtD,iDAAG,KAAKlB,SAAS,IACjB,2EAA6B,EAAE;MAC/B;AACN;AACA;AACA;AACA;AACA;AACA;MACM,IAAI+D,iBAAiB,KAAK/D,SAAS,EAAE;QACnC;MACF;MACA,MAAMyE,EAAE,GAAIV,iBAAiB,GAAG,IAAIW,oBAAoB,CAAEC,EAAE,IAAK;QAC/D;AACR;AACA;AACA;QACQ,IAAIA,EAAE,CAAC,CAAC,CAAC,CAACC,iBAAiB,KAAK,CAAC,EAAE;UACjCT,aAAa,EAAE;UACfM,EAAE,CAAC/B,UAAU,EAAE;UACfqB,iBAAiB,GAAG/D,SAAS;QAC/B;MACF,CAAC;MACD;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACM;QAAE6E,SAAS,EAAE,IAAI;QAAEpE,IAAI,EAAEb;MAAG,CAAC,CAAE;MAC/B6E,EAAE,CAACnC,OAAO,CAAC2B,aAAa,CAAC;MACzB;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;IACIA,aAAa,CAACG,KAAK,CAACU,WAAW,CAAC,OAAO,EAAG,GAAER,KAAK,GAAG,IAAK,IAAG,CAAC;EAC/D,CAAC;EACD,MAAMvB,OAAO,GAAG,MAAM;IACpB,IAAIgB,iBAAiB,EAAE;MACrBA,iBAAiB,CAACrB,UAAU,EAAE;MAC9BqB,iBAAiB,GAAG/D,SAAS;IAC/B;EACF,CAAC;EACD,OAAO;IACLkE,mBAAmB;IACnBnB;EACF,CAAC;AACH,CAAC","sources":["./node_modules/@ionic/core/dist/esm/form-controller-ed77647a.js","./node_modules/@ionic/core/dist/esm/input.utils-ec063df4.js","./node_modules/@ionic/core/dist/esm/notch-controller-8c9c0e54.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { h as findItemLabel } from './helpers-3379ba19.js';\n\n/**\n * Creates a controller that tracks whether a form control is using the legacy or modern syntax. This should be removed when the legacy form control syntax is removed.\n *\n * @internal\n * @prop el: The Ionic form component to reference\n */\nconst createLegacyFormController = (el) => {\n  const controlEl = el;\n  let legacyControl;\n  const hasLegacyControl = () => {\n    if (legacyControl === undefined) {\n      /**\n       * Detect if developers are using the legacy form control syntax\n       * so a deprecation warning is logged. This warning can be disabled\n       * by either using the new `label` property or setting `aria-label`\n       * on the control.\n       * Alternatively, components that use a slot for the label\n       * can check to see if the component has slotted text\n       * in the light DOM.\n       */\n      const hasLabelProp = controlEl.label !== undefined || hasLabelSlot(controlEl);\n      const hasAriaLabelAttribute = controlEl.hasAttribute('aria-label') ||\n        // Shadow DOM form controls cannot use aria-labelledby\n        (controlEl.hasAttribute('aria-labelledby') && controlEl.shadowRoot === null);\n      const legacyItemLabel = findItemLabel(controlEl);\n      /**\n       * Developers can manually opt-out of the modern form markup\n       * by setting `legacy=\"true\"` on components.\n       */\n      legacyControl =\n        controlEl.legacy === true || (!hasLabelProp && !hasAriaLabelAttribute && legacyItemLabel !== null);\n    }\n    return legacyControl;\n  };\n  return { hasLegacyControl };\n};\nconst hasLabelSlot = (controlEl) => {\n  const root = controlEl.shadowRoot;\n  if (root === null) {\n    return false;\n  }\n  /**\n   * Components that have a named label slot\n   * also have other slots, so we need to query for\n   * anything that is explicitly passed to slot=\"label\"\n   */\n  if (NAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.querySelector('[slot=\"label\"]') !== null) {\n    return true;\n  }\n  /**\n   * Components that have an unnamed slot for the label\n   * have no other slots, so we can check the textContent\n   * of the element.\n   */\n  if (UNNAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.textContent !== '') {\n    return true;\n  }\n  return false;\n};\nconst NAMED_LABEL_SLOT_COMPONENTS = ['ION-RANGE'];\nconst UNNAMED_LABEL_SLOT_COMPONENTS = ['ION-TOGGLE', 'ION-CHECKBOX', 'ION-RADIO'];\n\nexport { createLegacyFormController as c };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-7a14ecec.js';\nimport { r as raf } from './helpers-3379ba19.js';\nimport { a as printIonError } from './index-595d62c9.js';\n\n/**\n * Used to update a scoped component that uses emulated slots. This fires when\n * content is passed into the slot or when the content inside of a slot changes.\n * This is not needed for components using native slots in the Shadow DOM.\n * @internal\n * @param el The host element to observe\n * @param slotName mutationCallback will fire when nodes on this slot change\n * @param mutationCallback The callback to fire whenever the slotted content changes\n */\nconst createSlotMutationController = (el, slotName, mutationCallback) => {\n  let hostMutationObserver;\n  let slottedContentMutationObserver;\n  if (win !== undefined && 'MutationObserver' in win) {\n    hostMutationObserver = new MutationObserver((entries) => {\n      for (const entry of entries) {\n        for (const node of entry.addedNodes) {\n          /**\n           * Check to see if the added node\n           *  is our slotted content.\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            /**\n             * If so, we want to watch the slotted\n             * content itself for changes. This lets us\n             * detect when content inside of the slot changes.\n             */\n            mutationCallback();\n            /**\n             * Adding the listener in an raf\n             * waits until Stencil moves the slotted element\n             * into the correct place in the event that\n             * slotted content is being added.\n             */\n            raf(() => watchForSlotChange(node));\n            return;\n          }\n        }\n      }\n    });\n    hostMutationObserver.observe(el, {\n      childList: true,\n    });\n  }\n  /**\n   * Listen for changes inside of the slotted content.\n   * We can listen for subtree changes here to be\n   * informed of text within the slotted content\n   * changing. Doing this on the host is possible\n   * but it is much more expensive to do because\n   * it also listens for changes to the internals\n   * of the component.\n   */\n  const watchForSlotChange = (slottedEl) => {\n    var _a;\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n    slottedContentMutationObserver = new MutationObserver((entries) => {\n      mutationCallback();\n      for (const entry of entries) {\n        for (const node of entry.removedNodes) {\n          /**\n           * If the element was removed then we\n           * need to destroy the MutationObserver\n           * so the element can be garbage collected.\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            destroySlottedContentObserver();\n          }\n        }\n      }\n    });\n    /**\n     * Listen for changes inside of the element\n     * as well as anything deep in the tree.\n     * We listen on the parentElement so that we can\n     * detect when slotted element itself is removed.\n     */\n    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, { subtree: true, childList: true });\n  };\n  const destroy = () => {\n    if (hostMutationObserver) {\n      hostMutationObserver.disconnect();\n      hostMutationObserver = undefined;\n    }\n    destroySlottedContentObserver();\n  };\n  const destroySlottedContentObserver = () => {\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n  };\n  return {\n    destroy,\n  };\n};\n\nconst getCounterText = (value, maxLength, counterFormatter) => {\n  const valueLength = value == null ? 0 : value.toString().length;\n  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\n  /**\n   * If developers did not pass a custom formatter,\n   * use the default one.\n   */\n  if (counterFormatter === undefined) {\n    return defaultCounterText;\n  }\n  /**\n   * Otherwise, try to use the custom formatter\n   * and fallback to the default formatter if\n   * there was an error.\n   */\n  try {\n    return counterFormatter(valueLength, maxLength);\n  }\n  catch (e) {\n    printIonError('Exception in provided `counterFormatter`.', e);\n    return defaultCounterText;\n  }\n};\nconst defaultCounterFormatter = (length, maxlength) => {\n  return `${length} / ${maxlength}`;\n};\n\nexport { createSlotMutationController as c, getCounterText as g };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-7a14ecec.js';\nimport { r as raf } from './helpers-3379ba19.js';\n\n/**\n * A utility to calculate the size of an outline notch\n * width relative to the content passed. This is used in\n * components such as `ion-select` with `fill=\"outline\"`\n * where we need to pass slotted HTML content. This is not\n * needed when rendering plaintext content because we can\n * render the plaintext again hidden with `opacity: 0` inside\n * of the notch. As a result we can rely on the intrinsic size\n * of the element to correctly compute the notch width. We\n * cannot do this with slotted content because we cannot project\n * it into 2 places at once.\n *\n * @internal\n * @param el: The host element\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\n * @param getLabelSlot: A function that returns a reference to the slotted content.\n */\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\n  let notchVisibilityIO;\n  const needsExplicitNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (\n    /**\n     * If the notch is not being used\n     * then we do not need to set the notch width.\n     */\n    notchSpacerEl === undefined ||\n      /**\n       * If either the label property is being\n       * used or the label slot is not defined,\n       * then we do not need to estimate the notch width.\n       */\n      el.label !== undefined ||\n      getLabelSlot() === null) {\n      return false;\n    }\n    return true;\n  };\n  const calculateNotchWidth = () => {\n    if (needsExplicitNotchWidth()) {\n      /**\n       * Run this the frame after\n       * the browser has re-painted the host element.\n       * Otherwise, the label element may have a width\n       * of 0 and the IntersectionObserver will be used.\n       */\n      raf(() => {\n        setNotchWidth();\n      });\n    }\n  };\n  /**\n   * When using a label prop we can render\n   * the label value inside of the notch and\n   * let the browser calculate the size of the notch.\n   * However, we cannot render the label slot in multiple\n   * places so we need to manually calculate the notch dimension\n   * based on the size of the slotted content.\n   *\n   * This function should only be used to set the notch width\n   * on slotted label content. The notch width for label prop\n   * content is automatically calculated based on the\n   * intrinsic size of the label text.\n   */\n  const setNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (notchSpacerEl === undefined) {\n      return;\n    }\n    if (!needsExplicitNotchWidth()) {\n      notchSpacerEl.style.removeProperty('width');\n      return;\n    }\n    const width = getLabelSlot().scrollWidth;\n    if (\n    /**\n     * If the computed width of the label is 0\n     * and notchSpacerEl's offsetParent is null\n     * then that means the element is hidden.\n     * As a result, we need to wait for the element\n     * to become visible before setting the notch width.\n     *\n     * We do not check el.offsetParent because\n     * that can be null if the host element has\n     * position: fixed applied to it.\n     * notchSpacerEl does not have position: fixed.\n     */\n    width === 0 &&\n      notchSpacerEl.offsetParent === null &&\n      win !== undefined &&\n      'IntersectionObserver' in win) {\n      /**\n       * If there is an IO already attached\n       * then that will update the notch\n       * once the element becomes visible.\n       * As a result, there is no need to create\n       * another one.\n       */\n      if (notchVisibilityIO !== undefined) {\n        return;\n      }\n      const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\n        /**\n         * If the element is visible then we\n         * can try setting the notch width again.\n         */\n        if (ev[0].intersectionRatio === 1) {\n          setNotchWidth();\n          io.disconnect();\n          notchVisibilityIO = undefined;\n        }\n      }, \n      /**\n       * Set the root to be the host element\n       * This causes the IO callback\n       * to be fired in WebKit as soon as the element\n       * is visible. If we used the default root value\n       * then WebKit would only fire the IO callback\n       * after any animations (such as a modal transition)\n       * finished, and there would potentially be a flicker.\n       */\n      { threshold: 0.01, root: el }));\n      io.observe(notchSpacerEl);\n      return;\n    }\n    /**\n     * If the element is visible then we can set the notch width.\n     * The notch is only visible when the label is scaled,\n     * which is why we multiply the width by 0.75 as this is\n     * the same amount the label element is scaled by in the host CSS.\n     * (See $form-control-label-stacked-scale in ionic.globals.scss).\n     */\n    notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\n  };\n  const destroy = () => {\n    if (notchVisibilityIO) {\n      notchVisibilityIO.disconnect();\n      notchVisibilityIO = undefined;\n    }\n  };\n  return {\n    calculateNotchWidth,\n    destroy,\n  };\n};\n\nexport { createNotchController as c };\n"],"names":["h","findItemLabel","createLegacyFormController","el","controlEl","legacyControl","hasLegacyControl","undefined","hasLabelProp","label","hasLabelSlot","hasAriaLabelAttribute","hasAttribute","shadowRoot","legacyItemLabel","legacy","root","NAMED_LABEL_SLOT_COMPONENTS","includes","tagName","querySelector","UNNAMED_LABEL_SLOT_COMPONENTS","textContent","c","w","win","r","raf","a","printIonError","createSlotMutationController","slotName","mutationCallback","hostMutationObserver","slottedContentMutationObserver","MutationObserver","entries","entry","node","addedNodes","nodeType","Node","ELEMENT_NODE","slot","watchForSlotChange","observe","childList","slottedEl","_a","disconnect","removedNodes","destroySlottedContentObserver","parentElement","subtree","destroy","getCounterText","value","maxLength","counterFormatter","valueLength","toString","length","defaultCounterText","defaultCounterFormatter","e","maxlength","g","createNotchController","getNotchSpacerEl","getLabelSlot","notchVisibilityIO","needsExplicitNotchWidth","notchSpacerEl","calculateNotchWidth","setNotchWidth","style","removeProperty","width","scrollWidth","offsetParent","io","IntersectionObserver","ev","intersectionRatio","threshold","setProperty"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1,2]}